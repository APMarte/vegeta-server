// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Attack attack
// swagger:model Attack
type Attack struct {

	// Request body encoded as a json string
	Body string `json:"body,omitempty"`

	// TLS client PEM encoded certificate base64 encoded
	Cert string `json:"cert,omitempty"`

	// Max open idle connections per target host
	Connections *int64 `json:"connections,omitempty"`

	// Duration of the test
	// Required: true
	// Format: duration
	Duration *strfmt.Duration `json:"duration"`

	// Send HTTP/2 requests without TLS encryption
	H2c *bool `json:"h2c,omitempty"`

	// Request headers as a string array.
	Headers []*AttackHeadersItems0 `json:"headers"`

	// Send HTTP/2 requests when supported by the server
	Http2 *bool `json:"http2,omitempty"`

	// Specifies whether to ignore invalid server TLS certificates.
	Insecure bool `json:"insecure,omitempty"`

	// Specifies whether to reuse TCP connections between HTTP requests.
	Keepalive bool `json:"keepalive,omitempty"`

	// TLS cleint PEM encoded private key base64 encoded
	Key string `json:"key,omitempty"`

	// Specifies the local IP address to be used.
	// Format: ipv4
	Laddr strfmt.IPv4 `json:"laddr,omitempty"`

	// Specifies the maximum number of bytes to capture from the body of each response. Remaining unread bytes will be fully read but discarded. Set to -1 for no limit.
	MaxBody int64 `json:"max-body,omitempty"`

	// Specifies the request rate per time unit to issue against the targets. The actual request rate can vary slightly due to things like garbage collection, but overall it should stay very close to the specified. If no time unit is provided, 1s is used.
	// Required: true
	Rate *int64 `json:"rate"`

	// Specifies the max number of redirects followed on each request. The default is 10. When the value is -1, redirects are not followed but the response is marked as successful.
	Redirects int64 `json:"redirects,omitempty"`

	// Specifies custom DNS resolver addresses to use for name resolution instead of the ones configured by the operating system. Works only on non Windows systems.
	Resolvers string `json:"resolvers,omitempty"`

	// Specifies the trusted TLS root CAs certificate strings as a comma separated list. If unspecified, the default system CAs certificates will be used.
	RootCerts string `json:"root-certs,omitempty"`

	// target
	// Required: true
	Target *Target `json:"target"`

	// Specifies the timeout for each request. The default is 0 which disables timeouts.
	Timeout string `json:"timeout,omitempty"`

	// Specifies the initial number of workers used in the attack. The actual number of workers will increase if necessary in order to sustain the requested rate.
	Workers *int64 `json:"workers,omitempty"`
}

// Validate validates this attack
func (m *Attack) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeaders(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLaddr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTarget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Attack) validateDuration(formats strfmt.Registry) error {

	if err := validate.Required("duration", "body", m.Duration); err != nil {
		return err
	}

	if err := validate.FormatOf("duration", "body", "duration", m.Duration.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Attack) validateHeaders(formats strfmt.Registry) error {

	if swag.IsZero(m.Headers) { // not required
		return nil
	}

	for i := 0; i < len(m.Headers); i++ {
		if swag.IsZero(m.Headers[i]) { // not required
			continue
		}

		if m.Headers[i] != nil {
			if err := m.Headers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("headers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Attack) validateLaddr(formats strfmt.Registry) error {

	if swag.IsZero(m.Laddr) { // not required
		return nil
	}

	if err := validate.FormatOf("laddr", "body", "ipv4", m.Laddr.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Attack) validateRate(formats strfmt.Registry) error {

	if err := validate.Required("rate", "body", m.Rate); err != nil {
		return err
	}

	return nil
}

func (m *Attack) validateTarget(formats strfmt.Registry) error {

	if err := validate.Required("target", "body", m.Target); err != nil {
		return err
	}

	if m.Target != nil {
		if err := m.Target.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("target")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Attack) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Attack) UnmarshalBinary(b []byte) error {
	var res Attack
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AttackHeadersItems0 attack headers items0
// swagger:model AttackHeadersItems0
type AttackHeadersItems0 struct {

	// key
	Key string `json:"key,omitempty"`

	// value
	Value string `json:"value,omitempty"`
}

// Validate validates this attack headers items0
func (m *AttackHeadersItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AttackHeadersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AttackHeadersItems0) UnmarshalBinary(b []byte) error {
	var res AttackHeadersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
